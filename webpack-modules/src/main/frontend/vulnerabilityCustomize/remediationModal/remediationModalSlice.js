/*
 * Copyright (c) 2011-present Sonatype, Inc. All rights reserved.
 * Includes the third-party code listed at http://links.sonatype.com/products/clm/attributions.
 * "Sonatype" is a trademark of Sonatype, Inc.
 */
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { nxTextInputStateHelpers, nxFormSelectStateHelpers } from '@sonatype/react-shared-components';
import { append, without } from 'ramda';
import axios from 'axios';
import { Messages } from 'MainRoot/utilAngular/CommonServices';
import { startSaveMaskSuccessTimer } from 'MainRoot/util/reduxUtil';
import { propSet, eqValues } from 'MainRoot/util/jsUtil';
import { validateNonEmpty } from 'MainRoot/util/validationUtil';
import { selectVulnerabilityCustomize } from 'MainRoot/vulnerabilityCustomize/vulnerabilityCustomizeSelectors';
import {
  getVulnerabilityCustomRemediationIdUrl,
  getVulnerabilityCustomRemediationUrl,
} from 'MainRoot/util/CLMLocation';
import { stateReload } from 'MainRoot/reduxUiRouter/routerActions';
import { selectRemediationModalSlice } from './remediationModalSelectors';
import { SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS } from '@sonatype/react-shared-components';

const { initialState: rscInitialState, userInput } = nxTextInputStateHelpers;
const { initialState: rscInitialSelectState, userInput: userSelectInput } = nxFormSelectStateHelpers;

const REDUCER_NAME = 'Remediation';

export const initialState = {
  submitError: null,
  submitMaskState: null,
  isModalOpen: false,
  isEditMode: false,
  isDirty: false,
  customRemediationMessageInput: rscInitialState(''),
  customRemediationScopeInput: rscInitialSelectState(''),
  appCategoriesFromSelectedScope: null,
  selectedAppCategories: [],
  auditCommentInput: rscInitialState(''),
  isUnsavedChangesModalOpen: false,
  validationError: false,
  storedCustomRemediation: null,
};

const loadRemediationModal = (state, { payload: { storedCustomRemediation, appCategoriesByOwners, ownerInPath } }) => {
  state.isEditMode = !!storedCustomRemediation;
  state.storedCustomRemediation = storedCustomRemediation;
  state.customRemediationMessageInput = rscInitialState(storedCustomRemediation?.remediation || '');
  state.customRemediationScopeInput = rscInitialSelectState(storedCustomRemediation?.ownerId || ownerInPath.id);
  state.auditCommentInput = rscInitialState('');

  const isApplicationScope = (storedCustomRemediation?.ownerType || ownerInPath.type) === 'application';
  if (!isApplicationScope) {
    const currentOwnerId = storedCustomRemediation?.ownerId || ownerInPath.id;
    state.appCategoriesFromSelectedScope = appCategoriesByOwners.find(
      ({ ownerId }) => ownerId === currentOwnerId
    ).applicationCategories;
  }

  state.selectedAppCategories = storedCustomRemediation?.applicationCategoryIds || [];
  state.validationError = state.isEditMode ? null : validateNonEmpty(state.customRemediationMessageInput.value);
};

const closeModal = (state, { payload }) => {
  if (payload?.isDirty) {
    state.isUnsavedChangesModalOpen = true;
    return;
  }
  Object.assign(state, initialState);
};

const closeUnsavedChangesModal = (state) => {
  state.isUnsavedChangesModalOpen = false;
};

const requestFulfilled = (state) => {
  state.isDirty = false;
  state.submitError = null;
  state.submitMaskState = true;
};

const requestFailed = (state, { payload }) => {
  state.submitMaskState = null;
  state.submitError = Messages.getHttpErrorMessage(payload);
};

const computeIsDirty = (state) => {
  const {
    customRemediationMessageInput,
    customRemediationScopeInput,
    selectedAppCategories,
    auditCommentInput,
    storedCustomRemediation,
  } = state;

  if (!state.isEditMode) {
    state.isDirty =
      !!customRemediationMessageInput.value ||
      !customRemediationScopeInput.isPristine ||
      selectedAppCategories.length > 0 ||
      !!auditCommentInput.value;
    return;
  }

  state.isDirty =
    customRemediationMessageInput.value !== storedCustomRemediation.remediation ||
    customRemediationScopeInput.value !== storedCustomRemediation.ownerId ||
    !eqValues(selectedAppCategories, storedCustomRemediation.applicationCategoryIds || []) ||
    !!auditCommentInput.value;
};

const saveRemediation = createAsyncThunk(
  `${REDUCER_NAME}/saveRemediation`,
  async (_, { getState, dispatch, rejectWithValue }) => {
    const state = getState();
    const {
      customRemediationMessageInput,
      customRemediationScopeInput,
      selectedAppCategories,
      auditCommentInput,
      storedCustomRemediation,
    } = selectRemediationModalSlice(state);
    const { refId, componentIdentifier, ownersFromPath } = selectVulnerabilityCustomize(state);

    const newData = {
      ownerId: customRemediationScopeInput.value,
      refId: refId,
      remediation: customRemediationMessageInput.trimmedValue,
      applicationCategoryIds: selectedAppCategories,
      comment: auditCommentInput.trimmedValue,
    };
    if (componentIdentifier) {
      newData.componentIdentifier = componentIdentifier;
    }

    const selectedOwnerType = ownersFromPath.find(({ id }) => id === newData.ownerId).type;

    if (newData.remediation === '' && storedCustomRemediation?.id) {
      try {
        await axios.delete(
          getVulnerabilityCustomRemediationIdUrl(selectedOwnerType, newData.ownerId, storedCustomRemediation.id)
        );
      } catch (err) {
        return rejectWithValue(err);
      }
      startSaveMaskSuccessTimer(dispatch, actions.closeModal);
      return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
    }
    try {
      await axios.post(getVulnerabilityCustomRemediationUrl(selectedOwnerType, newData.ownerId), newData);
    } catch (err) {
      return rejectWithValue(err);
    }
    startSaveMaskSuccessTimer(dispatch, actions.closeModal);
    return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
  }
);

const setRemediation = (state, { payload: { value } }) => {
  state.customRemediationMessageInput = userInput(null, value);
  state.validationError = state.isEditMode ? null : validateNonEmpty(value);
  computeIsDirty(state);
};

const setAuditComment = (state, { payload: { value } }) => {
  state.auditCommentInput = userInput(null, value);
  computeIsDirty(state);
};

const setScope = (state, { payload: { evt, appCategoriesByOwners } }) => {
  const { selectedIndex, options } = evt.currentTarget;
  state.customRemediationScopeInput = userSelectInput(options[selectedIndex].value);

  const appCategoriesFromSelectedScope = appCategoriesByOwners.find(
    ({ ownerId }) => ownerId === options[selectedIndex].value
  );

  state.appCategoriesFromSelectedScope = appCategoriesFromSelectedScope?.applicationCategories;
  state.selectedAppCategories = [];

  computeIsDirty(state);
};

const setAppCategories = (state, { payload: appCategoryId }) => {
  state.selectedAppCategories = state.selectedAppCategories.includes(appCategoryId)
    ? without(appCategoryId, state.selectedAppCategories)
    : append(appCategoryId, state.selectedAppCategories);

  computeIsDirty(state);
};

const remediation = createSlice({
  name: REDUCER_NAME,
  initialState,
  reducers: {
    openModal: propSet('isModalOpen', true),
    closeModal,
    setRemediation,
    setAuditComment,
    setScope,
    setAppCategories,
    closeUnsavedChangesModal,
    loadRemediationModal,
  },
  extraReducers: {
    [saveRemediation.pending]: propSet('submitMaskState', false),
    [saveRemediation.fulfilled]: requestFulfilled,
    [saveRemediation.rejected]: requestFailed,
  },
});

export default remediation.reducer;
export const actions = {
  ...remediation.actions,
  saveRemediation,
};
