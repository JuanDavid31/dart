/*
 * Copyright (c) 2011-present Sonatype, Inc. All rights reserved.
 * Includes the third-party code listed at http://links.sonatype.com/products/clm/attributions.
 * "Sonatype" is a trademark of Sonatype, Inc.
 */
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { nxTextInputStateHelpers, nxFormSelectStateHelpers } from '@sonatype/react-shared-components';
import { append, without } from 'ramda';
import axios from 'axios';
import { Messages } from 'MainRoot/utilAngular/CommonServices';
import { propSet, eqValues } from 'MainRoot/util/jsUtil';
import { validateNonEmpty } from 'MainRoot/util/validationUtil';
import { selectVulnerabilityCustomize } from 'MainRoot/vulnerabilityCustomize/vulnerabilityCustomizeSelectors';
import { selectCvssSeverityModalSlice } from './cvssSeverityModalSelectors';
import { startSaveMaskSuccessTimer } from 'MainRoot/util/reduxUtil';
import { stateReload } from 'MainRoot/reduxUiRouter/routerActions';
import {
  getVulnerabilityCustomCvssSeverityIdUrl,
  getVulnerabilityCustomCvssSeverityUrl,
} from 'MainRoot/util/CLMLocation';
import { SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS } from '@sonatype/react-shared-components';

const { initialState: rscInitialState, userInput } = nxTextInputStateHelpers;
const { initialState: rscInitialSelectState, userInput: userSelectInput } = nxFormSelectStateHelpers;

const REDUCER_NAME = 'CvssSeverity';

const validateSeverity = (val) => {
  const validNumber = new RegExp(/^(\d{1,2})(\.\d)?$/);
  if (!validNumber.test(val)) {
    return 'Only numbers are accepted in the format XX.X';
  }

  const severity = parseFloat(val);
  return !isNaN(severity) && severity >= 0.0 && severity <= 10.0
    ? null
    : 'The Severity value should be between 0 and 10.0';
};

const validateRequiredFields = (state) => {
  return !state.isEditMode && !state.customCvssSeverityInput.trimmedValue
    ? 'Custom value for CVSS Severity is required'
    : null;
};

export const initialState = {
  submitError: null,
  submitMaskState: null,
  isModalOpen: false,
  isEditMode: false,
  isDirty: false,
  customCvssSeverityInput: rscInitialState('', validateSeverity),
  customCvssSeverityScopeInput: rscInitialSelectState(''),
  appCategoriesFromSelectedScope: null,
  selectedAppCategories: [],
  auditCommentInput: rscInitialState(''),
  isUnsavedChangesModalOpen: false,
  validationError: false,
  storedCustomCvssSeverity: null,
};

const loadCvssSeverityModal = (
  state,
  { payload: { storedCustomCvssSeverity, appCategoriesByOwners, ownerInPath } }
) => {
  state.isEditMode = !!storedCustomCvssSeverity;
  state.storedCustomCvssSeverity = storedCustomCvssSeverity;
  if (storedCustomCvssSeverity?.severity?.toString()) {
    state.customCvssSeverityInput = rscInitialState(storedCustomCvssSeverity.severity.toString(), validateSeverity);
  } else {
    state.customCvssSeverityInput = rscInitialState('');
  }
  state.customCvssSeverityScopeInput = rscInitialSelectState(storedCustomCvssSeverity?.ownerId || ownerInPath.id);
  state.auditCommentInput = rscInitialState('');

  const isApplicationScope = (storedCustomCvssSeverity?.ownerType || ownerInPath.type) === 'application';
  if (!isApplicationScope) {
    const currentOwnerId = storedCustomCvssSeverity?.ownerId || ownerInPath.id;
    state.appCategoriesFromSelectedScope = appCategoriesByOwners.find(
      ({ ownerId }) => ownerId === currentOwnerId
    ).applicationCategories;
  }

  state.selectedAppCategories = storedCustomCvssSeverity?.applicationCategoryIds || [];
  state.validationError = state.isEditMode ? null : validateNonEmpty(state.customCvssSeverityInput.value);
};

const closeModal = (state, { payload }) => {
  if (payload?.isDirty) {
    state.isUnsavedChangesModalOpen = true;
    return;
  }
  Object.assign(state, initialState);
};

const closeUnsavedChangesModal = (state) => {
  state.isUnsavedChangesModalOpen = false;
};

const requestFulfilled = (state) => {
  state.isDirty = false;
  state.submitError = null;
  state.submitMaskState = true;
};

const requestFailed = (state, { payload }) => {
  state.submitMaskState = null;
  state.submitError = Messages.getHttpErrorMessage(payload);
};

const computeIsDirty = (state) => {
  const {
    customCvssSeverityInput,
    customCvssSeverityScopeInput,
    selectedAppCategories,
    auditCommentInput,
    storedCustomCvssSeverity,
  } = state;

  if (!state.isEditMode) {
    state.isDirty =
      !!customCvssSeverityInput.value ||
      !customCvssSeverityScopeInput.isPristine ||
      selectedAppCategories.length > 0 ||
      !!auditCommentInput.value;
    return;
  }

  state.isDirty =
    customCvssSeverityInput.value !== storedCustomCvssSeverity.severity.toString() ||
    customCvssSeverityScopeInput.value !== storedCustomCvssSeverity.ownerId ||
    !eqValues(selectedAppCategories, storedCustomCvssSeverity.applicationCategoryIds || []) ||
    !!auditCommentInput.value;
};

const formatSeverity = (n) => (n.length > 0 ? parseFloat(n).toFixed(1).toString() : '');

const saveCvssSeverity = createAsyncThunk(
  `${REDUCER_NAME}/saveCvssSeverity`,
  async (_, { getState, dispatch, rejectWithValue }) => {
    const state = getState();
    const {
      customCvssSeverityInput,
      customCvssSeverityScopeInput,
      selectedAppCategories,
      auditCommentInput,
      storedCustomCvssSeverity,
    } = selectCvssSeverityModalSlice(state);
    const { refId, componentIdentifier, ownersFromPath } = selectVulnerabilityCustomize(state);

    const newData = {
      ownerId: customCvssSeverityScopeInput.value,
      refId: refId,
      severity: formatSeverity(customCvssSeverityInput.trimmedValue),
      applicationCategoryIds: selectedAppCategories,
      comment: auditCommentInput.trimmedValue,
    };
    if (componentIdentifier) {
      newData.componentIdentifier = componentIdentifier;
    }

    const selectedOwnerType = ownersFromPath.find(({ id }) => id === newData.ownerId).type;

    if (newData.severity === '' && storedCustomCvssSeverity?.id) {
      try {
        await axios.delete(
          getVulnerabilityCustomCvssSeverityIdUrl(selectedOwnerType, newData.ownerId, storedCustomCvssSeverity.id)
        );
      } catch (err) {
        return rejectWithValue(err);
      }
      startSaveMaskSuccessTimer(dispatch, actions.closeModal);
      return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
    }
    try {
      await axios.post(getVulnerabilityCustomCvssSeverityUrl(selectedOwnerType, newData.ownerId), newData);
    } catch (err) {
      return rejectWithValue(err);
    }
    startSaveMaskSuccessTimer(dispatch, actions.closeModal);
    return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
  }
);

const setCvssSeverity = (state, { payload: { value } }) => {
  if (value.length > 0) {
    state.customCvssSeverityInput = userInput(validateSeverity, value);
    state.validationError = validateSeverity(value);
  } else {
    state.customCvssSeverityInput = userInput(null, value);
    state.validationError = validateRequiredFields(state);
  }
  computeIsDirty(state);
};

const setAuditComment = (state, { payload: { value } }) => {
  state.auditCommentInput = userInput(null, value);
  computeIsDirty(state);
};

const setScope = (state, { payload: { evt, appCategoriesByOwners } }) => {
  const { selectedIndex, options } = evt.currentTarget;
  state.customCvssSeverityScopeInput = userSelectInput(options[selectedIndex].value);

  const appCategoriesFromSelectedScope = appCategoriesByOwners.find(
    ({ ownerId }) => ownerId === options[selectedIndex].value
  );

  state.appCategoriesFromSelectedScope = appCategoriesFromSelectedScope?.applicationCategories;
  state.selectedAppCategories = [];

  computeIsDirty(state);
};

const setAppCategories = (state, { payload: appCategoryId }) => {
  state.selectedAppCategories = state.selectedAppCategories.includes(appCategoryId)
    ? without(appCategoryId, state.selectedAppCategories)
    : append(appCategoryId, state.selectedAppCategories);

  computeIsDirty(state);
};

const cvssSeverity = createSlice({
  name: REDUCER_NAME,
  initialState,
  reducers: {
    openModal: propSet('isModalOpen', true),
    closeModal,
    setCvssSeverity,
    setAuditComment,
    setScope,
    setAppCategories,
    closeUnsavedChangesModal,
    loadCvssSeverityModal,
  },
  extraReducers: {
    [saveCvssSeverity.pending]: propSet('submitMaskState', false),
    [saveCvssSeverity.fulfilled]: requestFulfilled,
    [saveCvssSeverity.rejected]: requestFailed,
  },
});

export default cvssSeverity.reducer;
export const actions = {
  ...cvssSeverity.actions,
  saveCvssSeverity,
};
