/*
 * Copyright (c) 2011-present Sonatype, Inc. All rights reserved.
 * Includes the third-party code listed at http://links.sonatype.com/products/clm/attributions.
 * "Sonatype" is a trademark of Sonatype, Inc.
 */
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { nxTextInputStateHelpers, nxFormSelectStateHelpers } from '@sonatype/react-shared-components';
import { append, without } from 'ramda';
import axios from 'axios';
import { Messages } from 'MainRoot/utilAngular/CommonServices';
import { propSet, eqValues } from 'MainRoot/util/jsUtil';
import { validateNonEmpty } from 'MainRoot/util/validationUtil';
import { selectVulnerabilityCustomize } from 'MainRoot/vulnerabilityCustomize/vulnerabilityCustomizeSelectors';
import { selectCvssVectorModalSlice } from 'MainRoot/vulnerabilityCustomize/cvssVectorStringModal/cvssVectorStringModalSelectors';
import { startSaveMaskSuccessTimer } from 'MainRoot/util/reduxUtil';
import { stateReload } from 'MainRoot/reduxUiRouter/routerActions';
import { getVulnerabilityCustomCvssVectorIdUrl, getVulnerabilityCustomCvssVectorUrl } from 'MainRoot/util/CLMLocation';
import { SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS } from '@sonatype/react-shared-components';

const { initialState: rscInitialState, userInput } = nxTextInputStateHelpers;
const { initialState: rscInitialSelectState, userInput: userSelectInput } = nxFormSelectStateHelpers;

const REDUCER_NAME = 'CvssVector';

const validateRequiredFields = (state) => {
  return !state.isEditMode && !state.customCvssVectorStringInput.trimmedValue
    ? 'Custom value for CVSS Vector String is required'
    : null;
};

export const initialState = {
  submitError: null,
  submitMaskState: null,
  isModalOpen: false,
  isEditMode: false,
  isDirty: false,
  customCvssVectorStringInput: rscInitialState(''),
  customCvssVectorScopeInput: rscInitialSelectState(''),
  appCategoriesFromSelectedScope: null,
  selectedAppCategories: [],
  auditCommentInput: rscInitialState(''),
  isUnsavedChangesModalOpen: false,
  validationError: false,
  storedCustomCvssVector: null,
};

const loadCvssVectorStringModal = (
  state,
  { payload: { storedCustomCvssVector, appCategoriesByOwners, ownerInPath } }
) => {
  state.isEditMode = !!storedCustomCvssVector;
  state.storedCustomCvssVector = storedCustomCvssVector;
  state.customCvssVectorStringInput = rscInitialState(storedCustomCvssVector?.vector || '');
  state.customCvssVectorScopeInput = rscInitialSelectState(storedCustomCvssVector?.ownerId || ownerInPath.id);
  state.auditCommentInput = rscInitialState('');

  const isApplicationScope = (storedCustomCvssVector?.ownerType || ownerInPath.type) === 'application';
  if (!isApplicationScope) {
    const currentOwnerId = storedCustomCvssVector?.ownerId || ownerInPath.id;
    state.appCategoriesFromSelectedScope = appCategoriesByOwners.find(
      ({ ownerId }) => ownerId === currentOwnerId
    ).applicationCategories;
  }

  state.selectedAppCategories = storedCustomCvssVector?.applicationCategoryIds || [];
  state.validationError = state.isEditMode ? null : validateNonEmpty(state.customCvssVectorStringInput.value);
};

const closeModal = (state, { payload }) => {
  if (payload?.isDirty) {
    state.isUnsavedChangesModalOpen = true;
    return;
  }
  Object.assign(state, initialState);
};

const closeUnsavedChangesModal = (state) => {
  state.isUnsavedChangesModalOpen = false;
};

const requestFulfilled = (state) => {
  state.isDirty = false;
  state.submitError = null;
  state.submitMaskState = true;
};

const requestFailed = (state, { payload }) => {
  state.submitMaskState = null;
  state.submitError = Messages.getHttpErrorMessage(payload);
};

const computeIsDirty = (state) => {
  const {
    customCvssVectorStringInput,
    customCvssVectorScopeInput,
    selectedAppCategories,
    auditCommentInput,
    storedCustomCvssVector,
  } = state;

  if (!state.isEditMode) {
    state.isDirty =
      !!customCvssVectorStringInput.value ||
      !customCvssVectorScopeInput.isPristine ||
      selectedAppCategories.length > 0 ||
      !!auditCommentInput.value;
    return;
  }

  state.isDirty =
    customCvssVectorStringInput.value !== storedCustomCvssVector.vector ||
    customCvssVectorScopeInput.value !== storedCustomCvssVector.ownerId ||
    !eqValues(selectedAppCategories, storedCustomCvssVector.applicationCategoryIds || []) ||
    !!auditCommentInput.value;
};

const saveCvssVectorString = createAsyncThunk(
  `${REDUCER_NAME}/saveCvssVectorString`,
  async (_, { getState, dispatch, rejectWithValue }) => {
    const state = getState();
    const {
      customCvssVectorStringInput,
      customCvssVectorScopeInput,
      selectedAppCategories,
      auditCommentInput,
      storedCustomCvssVector,
    } = selectCvssVectorModalSlice(state);
    const { refId, componentIdentifier, ownersFromPath } = selectVulnerabilityCustomize(state);

    const newData = {
      ownerId: customCvssVectorScopeInput.value,
      refId: refId,
      vector: customCvssVectorStringInput.trimmedValue,
      applicationCategoryIds: selectedAppCategories,
      comment: auditCommentInput.trimmedValue,
    };
    if (componentIdentifier) {
      newData.componentIdentifier = componentIdentifier;
    }

    const selectedOwnerType = ownersFromPath.find(({ id }) => id === newData.ownerId).type;

    if (newData.vector === '' && storedCustomCvssVector?.id) {
      try {
        await axios.delete(
          getVulnerabilityCustomCvssVectorIdUrl(selectedOwnerType, newData.ownerId, storedCustomCvssVector.id)
        );
      } catch (err) {
        return rejectWithValue(err);
      }
      startSaveMaskSuccessTimer(dispatch, actions.closeModal);
      return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
    }
    try {
      await axios.post(getVulnerabilityCustomCvssVectorUrl(selectedOwnerType, newData.ownerId), newData);
    } catch (err) {
      return rejectWithValue(err);
    }
    startSaveMaskSuccessTimer(dispatch, actions.closeModal);
    return setTimeout(() => dispatch(stateReload()), SUBMIT_MASK_SUCCESS_VISIBLE_TIME_MS);
  }
);

const setCvssVectorString = (state, { payload: { value } }) => {
  state.customCvssVectorStringInput = userInput(null, value);
  state.validationError = validateRequiredFields(state);
  computeIsDirty(state);
};

const setAuditComment = (state, { payload: { value } }) => {
  state.auditCommentInput = userInput(null, value);
  computeIsDirty(state);
};

const setScope = (state, { payload: { evt, appCategoriesByOwners } }) => {
  const { selectedIndex, options } = evt.currentTarget;
  state.customCvssVectorScopeInput = userSelectInput(options[selectedIndex].value);

  const appCategoriesFromSelectedScope = appCategoriesByOwners.find(
    ({ ownerId }) => ownerId === options[selectedIndex].value
  );

  state.appCategoriesFromSelectedScope = appCategoriesFromSelectedScope?.applicationCategories;
  state.selectedAppCategories = [];

  computeIsDirty(state);
};

const setAppCategories = (state, { payload: appCategoryId }) => {
  state.selectedAppCategories = state.selectedAppCategories.includes(appCategoryId)
    ? without(appCategoryId, state.selectedAppCategories)
    : append(appCategoryId, state.selectedAppCategories);

  computeIsDirty(state);
};

const cvssVector = createSlice({
  name: REDUCER_NAME,
  initialState,
  reducers: {
    openModal: propSet('isModalOpen', true),
    closeModal,
    setCvssVectorString,
    setAuditComment,
    setScope,
    setAppCategories,
    closeUnsavedChangesModal,
    loadCvssVectorStringModal,
  },
  extraReducers: {
    [saveCvssVectorString.pending]: propSet('submitMaskState', false),
    [saveCvssVectorString.fulfilled]: requestFulfilled,
    [saveCvssVectorString.rejected]: requestFailed,
  },
});

export default cvssVector.reducer;
export const actions = {
  ...cvssVector.actions,
  saveCvssVectorString,
};
